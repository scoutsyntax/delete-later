Option 1: Use Window Function (Single Pass)

SELECT COUNT(*) AS out_of_order_count
FROM (
    SELECT AUDIT_ID,
           LAST_UPDATED_DATE,
           LAG(LAST_UPDATED_DATE) OVER (ORDER BY AUDIT_ID) AS prev_timestamp
    FROM A_HOLDING
    WHERE AUDIT_ID > (SELECT MAX(AUDIT_ID) - 10000 FROM A_HOLDING)  -- Last 10K rows
)
WHERE LAST_UPDATED_DATE < prev_timestamp;
Option 2: Check Only Recent Data

SELECT COUNT(*)
FROM A_HOLDING a
WHERE a.LAST_UPDATED_DATE > SYSDATE - 7  -- Last 7 days
  AND EXISTS (
    SELECT 1 FROM A_HOLDING b
    WHERE b.AUDIT_ID < a.AUDIT_ID
      AND b.LAST_UPDATED_DATE > a.LAST_UPDATED_DATE
      AND b.LAST_UPDATED_DATE > SYSDATE - 7
);
Option 3: Sample Check (Fastest)

SELECT COUNT(*) AS out_of_order_count
FROM (
    SELECT AUDIT_ID,
           LAST_UPDATED_DATE,
           LAG(LAST_UPDATED_DATE) OVER (ORDER BY AUDIT_ID) AS prev_ts
    FROM A_HOLDING
    SAMPLE(1)  -- 1% random sample
)
WHERE LAST_UPDATED_DATE < prev_ts;
Option 4: Just 100 Consecutive IDs

WITH recent AS (
    SELECT MAX(AUDIT_ID) AS max_id FROM A_HOLDING
)
SELECT COUNT(*)
FROM (
    SELECT AUDIT_ID,
           LAST_UPDATED_DATE,
           LAG(LAST_UPDATED_DATE) OVER (ORDER BY AUDIT_ID) AS prev_ts
    FROM A_HOLDING, recent
    WHERE AUDIT_ID BETWEEN max_id - 100 AND max_id
)
WHERE LAST_UPDATED_DATE < prev_ts;
Option 5: Quick Spot Check (Instant)

SELECT AUDIT_ID, LAST_UPDATED_DATE
FROM A_HOLDING
WHERE AUDIT_ID > (SELECT MAX(AUDIT_ID) - 20 FROM A_HOLDING)
ORDER BY AUDIT_ID;
Then visually check: do timestamps always increase with AUDIT_ID?

AUDIT_ID	LAST_UPDATED_DATE
998	10:01:05
999	10:01:03 ‚Üê Out of order
1000	10:01:08
If any timestamp is earlier than the previous row, you have the problem.
